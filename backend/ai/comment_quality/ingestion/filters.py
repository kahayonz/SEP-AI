"""File filtering utilities to exclude vendor/library files."""

import re
from pathlib import Path
from typing import List, Set


# Common vendor/library directory patterns to exclude
DEFAULT_EXCLUDE_PATTERNS = [
    # JavaScript/Node
    'node_modules',
    'bower_components',
    'vendor',
    'vendors',
    'third_party',
    'third-party',
    'thirdparty',
    'external',
    'externals',
    'lib',
    'libs',
    'library',
    'libraries',
    
    # Python
    'site-packages',
    'dist-packages',
    'venv',
    'virtualenv',
    '.venv',
    'env',
    '.env',
    
    # Django static files
    'staticfiles',
    'static/admin',
    'static/vendor',
    
    # Build outputs
    'dist',
    'build',
    'out',
    '.next',
    '.nuxt',
    'public/vendor',
    'public/lib',
    
    # Documentation/examples that might include code
    'docs',
    'examples',
    'example',
    'test',
    'tests',
    '__tests__',
    'spec',
    'specs',
    
    # Version control and IDE
    '.git',
    '.svn',
    '.hg',
    
    # Package managers
    '.npm',
    '.yarn',
    'yarn-cache',
]


# Patterns in filenames that indicate vendor/generated code
FILENAME_EXCLUDE_PATTERNS = [
    r'\.min\.js$',  # Minified JavaScript
    r'\.bundle\.js$',  # Bundled JavaScript
    r'\.min\.css$',  # Minified CSS
    r'-min\.js$',  # Alternative minification naming
    r'\.pack\.js$',  # Packed JavaScript
    r'jquery[.-]',  # jQuery library
    r'bootstrap[.-]',  # Bootstrap
    r'angular[.-]',  # Angular
    r'react[.-]',  # React
    r'vue[.-]',  # Vue
    r'lodash[.-]',  # Lodash
    r'underscore[.-]',  # Underscore
    r'moment[.-]',  # Moment.js
    r'd3[.-]',  # D3.js
    r'select2[.-]',  # Select2
    r'\.generated\.',  # Generated files
    r'\.autogenerated\.',  # Auto-generated files
    r'_pb2\.py$',  # Protocol buffer generated Python files
    r'_pb2_grpc\.py$',  # gRPC generated Python files
]


# Patterns in file content that indicate vendor/generated code
CONTENT_EXCLUDE_PATTERNS = [
    # Copyright/license headers from well-known libraries
    r'Copyright.*jQuery Foundation',
    r'Copyright.*Bootstrap',
    r'Copyright.*Facebook.*React',
    r'Copyright.*Google Inc',
    r'Copyright.*Twitter',
    r'This file is automatically generated',
    r'DO NOT EDIT.*generated',
    r'@generated',
    r'Auto-generated',
    r'Autogenerated',
    
    # Minification indicators
    r'^/\*!.*\*/$',  # Minified license header on single line
]


class FileFilter:
    """Filters out vendor/library files from source code analysis."""
    
    def __init__(
        self,
        exclude_patterns: List[str] = None,
        exclude_filename_patterns: List[str] = None,
        min_comment_density: float = 0.0,
        max_file_size_kb: int = None,
        enable_minification_detection: bool = True,
        enable_content_analysis: bool = True,
        custom_exclude_paths: List[str] = None,
    ):
        """
        Initialize the file filter.
        
        Args:
            exclude_patterns: Directory patterns to exclude (uses defaults if None)
            exclude_filename_patterns: Filename patterns to exclude (uses defaults if None)
            min_comment_density: Minimum ratio of comment lines to total lines (0.0-1.0)
            max_file_size_kb: Maximum file size in KB (None = no limit)
            enable_minification_detection: Check for minified code
            enable_content_analysis: Analyze file content for vendor indicators
            custom_exclude_paths: Additional custom paths to exclude
        """
        self.exclude_patterns = exclude_patterns or DEFAULT_EXCLUDE_PATTERNS
        self.exclude_filename_patterns = exclude_filename_patterns or FILENAME_EXCLUDE_PATTERNS
        self.min_comment_density = min_comment_density
        self.max_file_size_kb = max_file_size_kb
        self.enable_minification_detection = enable_minification_detection
        self.enable_content_analysis = enable_content_analysis
        self.custom_exclude_paths = set(custom_exclude_paths or [])
        
        # Compile regex patterns for efficiency
        self.filename_regexes = [re.compile(pattern, re.IGNORECASE) for pattern in self.exclude_filename_patterns]
        self.content_regexes = [re.compile(pattern, re.IGNORECASE | re.MULTILINE) for pattern in CONTENT_EXCLUDE_PATTERNS]
    
    def should_exclude_file(self, file_path: str, project_root: str = None) -> tuple[bool, str]:
        """
        Determine if a file should be excluded.
        
        Args:
            file_path: Path to the file
            project_root: Root directory of the project (for relative path calculation)
            
        Returns:
            Tuple of (should_exclude: bool, reason: str)
        """
        path = Path(file_path)
        
        # Check custom exclude paths first
        if project_root:
            try:
                rel_path = path.relative_to(project_root)
                rel_path_str = str(rel_path).replace('\\', '/')
                for exclude_path in self.custom_exclude_paths:
                    if exclude_path in rel_path_str:
                        return True, f"Custom exclude path: {exclude_path}"
            except ValueError:
                pass  # Path is not relative to project_root
        
        # Check directory patterns
        path_parts = path.parts
        for pattern in self.exclude_patterns:
            for part in path_parts:
                if pattern.lower() in part.lower():
                    return True, f"Excluded directory: {pattern}"
        
        # Check filename patterns
        filename = path.name
        for regex in self.filename_regexes:
            if regex.search(filename):
                return True, f"Excluded filename pattern: {regex.pattern}"
        
        # Check file size
        if self.max_file_size_kb:
            try:
                size_kb = path.stat().st_size / 1024
                if size_kb > self.max_file_size_kb:
                    return True, f"File too large: {size_kb:.1f}KB > {self.max_file_size_kb}KB"
            except (OSError, FileNotFoundError):
                return True, "Cannot access file"
        
        # Content-based checks (more expensive, do last)
        if self.enable_content_analysis or self.enable_minification_detection or self.min_comment_density > 0:
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Check for vendor/generated content patterns
                if self.enable_content_analysis:
                    # Only check first 5000 characters for performance
                    header = content[:5000]
                    for regex in self.content_regexes:
                        if regex.search(header):
                            return True, f"Vendor/generated content pattern: {regex.pattern[:50]}"
                
                # Check for minified code
                if self.enable_minification_detection:
                    if self._is_minified(content):
                        return True, "Minified code detected"
                
                # Check comment density
                if self.min_comment_density > 0:
                    density = self._calculate_comment_density(content, file_path)
                    if density < self.min_comment_density:
                        return True, f"Low comment density: {density:.2%} < {self.min_comment_density:.2%}"
                        
            except (OSError, UnicodeDecodeError, MemoryError):
                # If we can't read the file, exclude it
                return True, "Cannot read file content"
        
        return False, ""
    
    def filter_files(self, file_paths: List[str], project_root: str = None, verbose: bool = False) -> tuple[List[str], dict]:
        """
        Filter a list of file paths.
        
        Args:
            file_paths: List of file paths to filter
            project_root: Root directory of the project
            verbose: Print exclusion reasons
            
        Returns:
            Tuple of (included_files: List[str], exclusion_stats: dict)
        """
        included = []
        exclusion_reasons = {}
        
        for file_path in file_paths:
            should_exclude, reason = self.should_exclude_file(file_path, project_root)
            
            if should_exclude:
                # Track exclusion reasons for statistics
                exclusion_reasons[reason] = exclusion_reasons.get(reason, 0) + 1
                if verbose:
                    print(f"Excluding: {file_path} - {reason}")
            else:
                included.append(file_path)
        
        stats = {
            'total_files': len(file_paths),
            'included_files': len(included),
            'excluded_files': len(file_paths) - len(included),
            'exclusion_reasons': exclusion_reasons
        }
        
        return included, stats
    
    def _is_minified(self, content: str) -> bool:
        """
        Detect if content appears to be minified.
        
        Heuristics:
        - Very long lines (>500 chars)
        - High ratio of code to newlines
        - Lack of indentation
        """
        lines = content.split('\n')
        
        if not lines:
            return False
        
        # Check for extremely long lines (typical of minified code)
        long_line_count = sum(1 for line in lines if len(line) > 500)
        if long_line_count > len(lines) * 0.1:  # More than 10% of lines are very long
            return True
        
        # Check average line length (minified code has very long lines)
        non_empty_lines = [line for line in lines if line.strip()]
        if non_empty_lines:
            avg_line_length = sum(len(line) for line in non_empty_lines) / len(non_empty_lines)
            if avg_line_length > 200:  # Very high average
                return True
        
        # Check for lack of indentation (minified code is typically not indented)
        indented_lines = sum(1 for line in lines if line.startswith((' ', '\t')) and line.strip())
        if len(non_empty_lines) > 10 and indented_lines < len(non_empty_lines) * 0.1:
            # Less than 10% of lines are indented
            return True
        
        return False
    
    def _calculate_comment_density(self, content: str, file_path: str) -> float:
        """
        Calculate the ratio of comment lines to total lines.
        
        Returns:
            Float between 0.0 and 1.0
        """
        lines = content.split('\n')
        if not lines:
            return 0.0
        
        comment_lines = 0
        in_multiline_comment = False
        
        # Determine file type
        ext = Path(file_path).suffix.lower()
        is_python = ext == '.py'
        is_javascript = ext in ['.js', '.jsx']
        
        for line in lines:
            stripped = line.strip()
            
            if not stripped:
                continue
            
            if is_python:
                # Python comments
                if stripped.startswith('#'):
                    comment_lines += 1
                elif '"""' in stripped or "'''" in stripped:
                    comment_lines += 1
                    # Note: This is simplified; proper detection would need more logic
            
            elif is_javascript:
                # JavaScript comments
                if in_multiline_comment:
                    comment_lines += 1
                    if '*/' in stripped:
                        in_multiline_comment = False
                elif stripped.startswith('//'):
                    comment_lines += 1
                elif stripped.startswith('/*'):
                    comment_lines += 1
                    if '*/' not in stripped:
                        in_multiline_comment = True
        
        return comment_lines / len(lines)
    
    def print_statistics(self, stats: dict):
        """Print filtering statistics in a readable format."""
        print("\n" + "="*60)
        print("FILE FILTERING STATISTICS")
        print("="*60)
        print(f"Total files found:     {stats['total_files']}")
        print(f"Files included:        {stats['included_files']} ({stats['included_files']/stats['total_files']*100:.1f}%)")
        print(f"Files excluded:        {stats['excluded_files']} ({stats['excluded_files']/stats['total_files']*100:.1f}%)")
        
        if stats['exclusion_reasons']:
            print("\nExclusion reasons:")
            for reason, count in sorted(stats['exclusion_reasons'].items(), key=lambda x: x[1], reverse=True):
                print(f"  - {reason}: {count} files")
        print("="*60 + "\n")


def create_default_filter(strict: bool = False) -> FileFilter:
    """
    Create a FileFilter with sensible defaults.
    
    Args:
        strict: If True, use stricter filtering (higher comment density requirement)
        
    Returns:
        Configured FileFilter instance
    """
    return FileFilter(
        min_comment_density=0.02 if strict else 0.0,  # 2% comment lines if strict
        max_file_size_kb=500,  # Exclude very large files (likely generated)
        enable_minification_detection=True,
        enable_content_analysis=True,
    )

